Island Perimeter:   O(R*C) r = rows, c = cols, at worst, dfs will visit every cell of the grid
                    0(R*C) r = rows, c = cols, the grid is used to store the visited cells, depending on whether this counts or not since we are reusing memeory given to us

Number of Island:   O(R*C) r = rows, c = cols, at worst, dfs will visit every cell of the grid
                    0(R*C) r = rows, c = cols, the grid is used to store the visited cells, this is the size of the recursive stack

Max Area:           O(ROWS * COLS * avg_island_size)
                    O(ROWS * COLS)

Sub Island:         O(ROWS*COLS) The dfs function is called for each cell in the grid2 (m x n times) during the double loop, and each cell is visited at most once.
                    O(min(m,n)) The primary space used is for recursion, which can go as deep as the dimensions of the grid. The maximum depth of recursion would be min(m, n), which represents the diagonal of the grid.

Flow of water:      O(ROWS * COLS) Since each DFS traversal potentially visits every cell once, the total time complexity of the code is O(ROWS * COLS).
                    O(ROWS * COLS) The pacific and atlantic sets can each store up to O(ROWS * COLS) cells, resulting in a total space complexity of O(ROWS * COLS).

Surrounded:         O(Rows * Cols) This is because the code iterates through each cell in the board exactly once during the three nested loops.
                    O(1) meaning it doesn't use any extra space that scales with the input size.